---
title: Taller \# 2
author: 
    - Juan Sebastian Gómez D.
    - Daniel Felipe Cendales G.
output: 
    html_notebook:
        toc: true
        toc_depth: 2
        toc_float: true
        number_sections: true
---

```{r Configuraciones globales, echo = FALSE}
# Configuraciones generales
knitr::opts_chunk$set(echo = FALSE, warnings = FALSE, message = FALSE, results = 'hide')
```

```{r}
carga_e_instala <- function(x){
    no_instalados <- !(x %in% installed.packages()[, 1])
    if(any(no_instalados)){
        install.packages(x[no_instalados])
    }
    sapply(x, library, logical.return = TRUE, character.only = TRUE)
}

paquetes <- c('fda', 'fda.usc', 'VGAM', 'ggplot2', 'plotly','patchwork')
carga_e_instala(paquetes)
```

# Producción de Azúcar {.tabset}

**Información del conjunto de datos:** azúcar se ha disuelto en agua sin amortiguar y la solución se midió espectrofluorométricamente en una cubeta de 10 $\times$ 10 $mm^2$. Los datos en bruto se midieron con un fluorómetro. Para cada muestra, los espectros de emisión se midieron en intervalos de $0.5$ nm en siete ondas de excitación.

Es decir, tenemos una muestra de tamaño 265, en 571 puntos para cada una de las 7 ondas de longitudes de excitación.

En nuestro caso, decidimos tomar el nivel de excitación correspondiente al nivel de onda 340. Para entender un poco mejor los datos, visualicemos la información sin haberla tratado (i.e. en bruto).

```{r Lectura de datos y Config. inicial}
# Lectura de datos
ruta <- './Datos/datos.txt'
datos1 <- read.table(colClasses = rep(c('NULL', 'numeric'), 
                                      c(6, 1)*571), file = ruta)
# Gráficos
t_rango <- seq(275, 560, by = 0.5)
matplot(x = t_rango, y = t(datos1), type = 'p', 
        pch = 19, cex = 0.2, frame = FALSE, 
        main = 'Datos observados',
        xlab = 'Emisión espectral', ylab = 'Fluoresencia')
```

Después de visualizar las funciones (sin suavizar) consideramos como más acertado usar una base de funciones *B-Spline* para llevar a cabo el suavizado, pues en los datos no se perciben comportamientos cíclicos (o sinusoidales). Como apunte adicional, mencionamos que para llevar a cabo el ajuste nos bastó con usar polinomios de grado 3 (orden 4) y para la parte que presentaba un apuntamiento muy alto usamos más *breakpoints*.

```{r Creación de base}
# Base que se va a usar
bk <- c(275, 285, 300, 320, 360.5, 389, 430, 470, 520, 560)
base_bsp <- create.bspline.basis(breaks = bk, norder = 4)
```

A continuación podemos ver las versiones suavizadas de la muestra en cuestión.

```{r}
ajuste <- Data2fd(y = as.matrix(t(datos1)), 
                  basisobj = base_bsp, 
                  argvals = t_rango)
plot(ajuste, frame = FALSE, main = 'Curvas Suavizadas', 
     ylab = 'Fluorescencia', xlab = 'Emisión espectral')
```

Para contrastar las estimaciones, vamos a superponer los datos sin tratar, junto con las respectivas curvas suavizadas.

```{r}
# Datos en bruto
matplot(x = t_rango, y = t(datos1), type = 'p', 
        pch = 19, cex = 0.1, frame = FALSE, 
        main = 'Muestras y curvas suavizadas asociadas', 
        xlab = 'Emisión espectral', ylab = 'Fluoresencia',
        col = 'black')

# Respectivas curvas suavizadas
lines(ajuste, lwd = 1, col = 'midnightblue', lty = 1)
legend(legend = c('Sin tratar', 'Suavizadas'), lwd = 2, 
       col = c('black', 'midnightblue'), pch = c(19, NA),
       pt.cex = 0.2, text.col = c('black', 'midnightblue'),
       x = 'topright', bg = 'gray82', box.col = 'white', 
       lty = c(NA, 1))
```

## Función de media

La función de media $\overline{x(t)}$ se presenta a continuación

```{r}
#  Extraemos los objetos ajustados
ajuste_detallado <- smooth.basis(argvals = t_rango, 
                                 y = t(datos1), 
                                 fdParobj = base_bsp)
# Funciones ajustadas
f_hat <- eval.fd(evalarg = t_rango, 
                 fdobj = ajuste_detallado$fd)
colnames(f_hat) <- paste0('v', 1:ncol(f_hat))

matplot(x = t_rango, y = t(datos1), type = 'p', 
        pch = 19, cex = 0.2, frame = FALSE, 
        main = 'Media y datos originales', 
        xlab = 'Emisión espectral', ylab = 'Fluoresencia',
        col = 'gray')

# Agregamos la función de media
y_media <- apply(X = f_hat, MARGIN = 1, mean)
lines(x = t_rango, y = y_media, col = 'black', lwd = 3)
legend(x = 'topright', legend = c('Media', 'Datos originales'),
       lwd = c(3, NA), col = c('black', 'gray'), 
       lty = c(1, NA), box.col = 'white', 
       pch = 19, pt.cex = c(NA, 0.2))

# Boxplot funcional
fbplot(fit = f_hat, x = t_rango, ylim = c(-10, 500), 
       main = 'Boxplot funcional', xlim = range(t_rango),
       plot = FALSE) -> bp_funcional
order(bp_funcional$depth) -> centrales
```

## Función de media recortada al 10%

Veremos la media recortada, que corresponde al cálculo de la media despúes de haber omitida una cantidad de observaciones (en este, el 10% de las observaciones *menos centrales*). Vemos que las funciones menos centrales, parecen mostrar un comportamiento, más apuntados en alguna parte o la parte central en lugar de ser decreciente crece.

```{r}
# Datos sin suavizar
matplot(x = t_rango, y = f_hat[, centrales[1:26]], type = 'l', 
        pch = 19, cex = 0.2, frame = FALSE, lty = 1, lwd = 0.8,
        col = 'cyan2', main = 'Media recortada', 
        xlab = 'Emisión espectral', ylab = 'Fluoresencia')
# Media recortada
y_mediarec <- apply(X = f_hat[, -centrales[1:26]], MARGIN = 1,
                    mean)

# Funciones graficadas
lines(x = t_rango, y = y_media, col = 'black', lwd = 2, 
      lty = 2)
lines(x = t_rango, y = y_mediarec, lwd = 3, col = 'red')

# Identificamos cada curva
legend(x = 'topright', legend = c('Media recortada', 'Media', 
                                  'Datos no considerados'), 
       lwd = c(3, 2, 0.8), col = c('red', 'black', 'cyan2'), 
       lty = c(1, 2, 1), box.col = 'white') 
```

## Función de varianza

Se calculó usando todos los datos.

```{r}
# Función de varianza
f_var <- apply(X = f_hat, MAR = 1, FUN = var)

# Graficamos
plot(x = t_rango, y = f_var, frame = FALSE, 
     main = 'Varianza estimada', 
     xlab = 'Emisión espectral', type = 'l', ylab = '')
```

## Función de covarianza

Mostramos la superficie obtenida. Con la función *persp* obtenemos una figura no muy agradable. Sin embargo, usaremos la función *plot_ly* que graficará la superficie en una página web y tomamos capturas de pantalla.

Aprovechamos para visualizar las funciones de *varianza y covarianza*, y la matriz de *correlaciones*.

```{r, include = TRUE}
# Función de autocovarianza
cov_f <- cov(t(f_hat))
cor_f <- cor(t(f_hat))

# Covarianza
ind_1 <- seq(from = 1, to = 571, by = 5)
g1 <- plot_ly(x = ~t_rango[ind_1], y = ~t_rango[ind_1], 
              z = ~cov_f[ind_1, ind_1], 
              showlegend = FALSE)
g11 <- g1 %>% add_surface() %>%
 layout(scene = list(xaxis = list(title = 'Emisión espectral'),
                                  yaxis = list(title = 'Emisión espectral'),
                                  zaxis = list(title = 'covarianza')))
print(g11)
# Correlación
g2 <- plot_ly(x = ~t_rango[ind_1], y = ~t_rango[ind_1], 
              z = ~cor_f[ind_1, ind_1], 
              showlegend = FALSE)
g12 <- g2 %>% add_surface() %>%
 layout(scene = list(xaxis = list(title = 'Emisión espectral'),
                                  yaxis = list(title = 'Emisión espectral'),
                                  zaxis = list(title = 'Correlación')))
print(g12)
```

![Covarianza](./Capturas/cov_vista1.png)

![Correlación](./Capturas/cor_vista1.png)

Otra forma de visualizarlo sería usando mapas de calor. A continucación

```{r}
# Mapas de calor
par(mfrow = c(1, 2))

# Covarianzas
image(x = t_rango, y = t_rango, z = cov_f, 
      main = 'Varianzas y covarianzas', 
      xlab = 'Emisión espectral', 
      ylab = 'Emisión espectral', frame = FALSE)

# Correlaciones
image(x = t_rango, y = t_rango, z = cor_f, 
      main = 'Matriz de correlaciones', 
      xlab = 'Emisión espectral', 
      ylab = 'Emisión espectral', frame = FALSE)
```

## La función de mediana

Corresponde a la estimación con la mayor densidad de todas las estimaciones.

```{r}
# Mediana
y_mediana <- f_hat[, which.max(bp_funcional$depth)]

# Grafiquemos las 3 funciones
matplot(x = t_rango, y = cbind(y_mediarec, y_media, y_mediana),
        lwd = c(1, 1, 2), col = c('black', 'blue', 'brown'), 
        type = 'l', frame = FALSE, lty = 1, 
        xlab = 'Emisión espectral', ylab = 'Fluoresencia', 
        main = 'Medidas de tendencia central')

legend(x = 'topright', box.col = 'white',
       legend = c('Mediana', 'Media', 'Media recortada'), 
       lwd = c(2, 1, 1), col = c('brown', 'blue', 'black'))
```

## Funciones cuantiles 90% y 95%

Cuando tomamos el $p\%$ de bandas más profundas y construimos la banda, fuera de la banda queda $(1-p)\%$ y por ende $\left(\frac{1-p}{2}\right)\%$ en los extremos. Luego, la banda máxima cubre $\left(p + \frac{1-p}{2}\right)\&$. Es decir, tenemos un cuantil que cubre: 

$q = \frac{1+p}{2} \implies p = 2q - 1$

Es decir, que si especificamos el cuantil $q$, podremos saber cual es la banda $p$ a elegir.

Entonces tenemos:

+ Al cuantil $q_{90}$ le corresponde la región $p = 0.8$
+ Al cuantil $q_{95}$ le corresponde la región $p = 0.9$

En el mismo gráfico presentamos las funciones de los cuantiles solicitados.

```{r}
# Gráfico de base
matplot(x = t_rango, y = f_hat, type = 'l', 
        pch = 19, cex = 0.2, frame = FALSE, 
        main = 'Cuantiles', lty = 1,
        xlab = 'Emisión espectral', ylab = 'Fluoresencia',
        col = 'gray')

cuant_95 <- apply(X = f_hat[, -centrales[1:18]], MAR = 1, max)
matlines(x = t_rango, y = cuant_95, col = 'blue', lwd = 3, 
         lty = 1)

p0 <- sum(apply(X = f_hat, MARGIN = 2, 
                function(x) all(x <= cuant_95)))
# Cuantiles 90%
cuant_90 <- apply(X = f_hat[, -centrales[1:51]], MAR = 1, max)
p1 <- sum(apply(X = f_hat, MARGIN = 2, 
                function(x) all(x <= cuant_90)))

matlines(x = t_rango, y = cuant_90, col = 'red', lwd = 2, 
         lty = 1)
legend(x = 'topright', lwd = 3:1, box.col = 'white',
       col = c('blue', 'red', 'gray'), 
       legend = c('Cuantil 95%', 'Cuantil 90%', 'Datos'))
```

## Región central 0.75

```{r}
# Base :v
matplot(x = t_rango, y = f_hat, type = 'l', pch = 19, 
        cex = 0.2, 
        frame = FALSE, main = 'Región 0.75', lty = 1,
        xlab = 'Emisión espectral', ylab = 'Fluoresencia',
        col = 'white')
cuant_75 <- cbind(apply(X = f_hat[, -centrales[1:67]], 
                        MAR = 1, min), 
                  apply(X = f_hat[, -centrales[1:67]], 
                        MAR = 1, max))

polygon(x = c(t_rango, t_rango[length(t_rango):1]), 
        y = c(cuant_75[,1], (cuant_75[,2])[length(t_rango):1]),
        border = 'midnightblue', angle = 45, 
        col = 'midnightblue', density = 50)
```

## Boxplot funcional y outliers

Los números que aparecen en la leyenda son los identificadores de las funciones $\widehat{x}$ consideradas como atípicas. En este caso, podemos considerar que se tratan de *outliers parciales*. Las observaciones 131, 71 y 10, tienen una región  (intervalo 350-450 aproximadamente) en la que las curvas o bien decrecen de forma muy suave o bien se comportan de forma creciente (contrario al boxplot que tenemos de fondo). 

```{r}
# Boxplot funcional
fbplot(fit = f_hat, x = t_rango, ylim = c(-10, 500), 
       frame = FALSE, main = 'Boxplot funcional', 
       xlim = range(t_rango), outliercol = 'white', 
       barcol = adjustcolor('midnightblue', alpha.f = 0.2), 
       color = adjustcolor('brown', alpha.f = 0.2),
       xlab = 'Emisión espectral', 
       ylab = 'Fluoresencia') -> bp_funcional

matlines(x = t_rango, y = f_hat[, bp_funcional$outpoint], 
         lty = 1,  lwd = 3, 
         col = c('blue4', 'deeppink4', 'indianred4'))

legend(legend = bp_funcional$outpoint, x = 'topright', lwd = 3,
       col = c('blue4', 'deeppink4', 'indianred4'), 
       ncol = 2, cex = 0.8, box.col = 'white', 
       lty = 1, bg = 'azure1')
```

## Boxplot funcional ajustado y outliers

1. Debido a las dificultades que encontramos para implementar la estimación de la *matriz de varianzas y covarianzas robusta* usamos dos formas. Primero con el paquete *roahd*.

La tasa positiva de outliers que usamos fue de 99.7%.

```{r}
# Librería especial
library(roahd)
set.seed(314)

# Estructura
f_d <- fData(grid = t_rango, values = t(f_hat))
pbf_1 <- fbplot(Data = f_d, Depths = 'MBD', 
                adjust = list(N_trials = 1, trial_size = 100,
                              TPR = 0.0007,
                              F_max = 2), display = FALSE)
f <- pbf_1$Fvalue
```

Con lo que obtuvimos un valor para el hiperparámetro *F* de `r round(f, 4)`.

```{r}
par(mfrow = c(2, 2))
out_2 <- list(x1 = c(1, 8, 9),
              x2 = c(2, 4, 10),
              x3 = c(3, 5:7))
col <- c('blue4', 'brown', 'gray45') 

for(i in 1:length(out_2)){
bp_f1 <- fda::fbplot(fit = f_hat, x = t_rango, ylim = c(-10, 500), 
                     frame = FALSE, main = 'Boxplot funcional', 
                     xlim = range(t_rango), factor = f,
                     barcol = adjustcolor('midnightblue', 
                                          alpha.f = 0.1), 
                     outliercol = 'white',
                     color = adjustcolor('brown', alpha.f = 0.1),
                     xlab = 'Emisión espectral', 
                     ylab = 'Fluoresencia')

matlines(x = t_rango, y = f_hat[, bp_f1$outpoint[ out_2[[i]]] ],
         lwd = 2,
         lty = 1:4,
         col = col[i])
legend(x = 'topright', legend = bp_f1$outpoint[out_2[[i]]], lty = 1:4, 
       lwd = 2, col = col[i], box.col = 'white', 
       bg = 'azure1')
}

```

Vemos que ajustando el factor, obtenemos los 3 outliers de antes (outliers parciales). De igual forma, los datos 13, 15 y 268 también resultan ser outliers parciales, pues vemos que en ciertas regiones se comportan de forma distinta al resto de funciones. Finalmente se obtienen los outliers correspondientes a los datos 14, 16, 17 y 38. Estos últimos es más difícil de justificar con una simple visualización, pues en las partes en donde salen del boxplot son muy pocas y pequeñas.

solo obtenemos 3 datos atípicos. Justamente los 3 datos que habíamos catalogados como outliers parciales (y que en cierta medida, era más sencillo justificar porqué eran outliers).

2. Como alternativa, proponemos basarnos en técnicas de remuestreo para estimar el boxplot sin usar los que parecen ser datos atípicos (es decir, sin considerar los 5 datos que considerabamos como outliers) y definir el valor del *hiperparámetro* F.

Los gráficos nos ayudan a ver el efecto de haber cambiado el factor $F$ de 1.5 a 1.74 y vemos que la proporción de datos catalogados como atípicos cuando no lo son pasa de un 5% a un 2%.

```{r}
# Fijamos semilla
set.seed(2)

# Índices sobre los que vamos a muestrear
ind <- (1:ncol(f_hat))[-bp_funcional$outpoint]

# Remuestreo
rem <- sample(x = ind, size = 100, replace = TRUE)

# Selección de observaciones
f_rem <- f_hat[, rem]

# Boxplot
par(mfrow = c(1, 2))
fda::fbplot(f_rem, x = t_rango, xlim = range(t_rango), 
            ylim = c(-5, 500), frame = FALSE, 
            xlab = 'Emisión espectral', cex.axis = 0.7,
            cex.lab = 0.7,
            ylab = 'Fluoresencia', 
            main = 'Remuestreo')$outpoint
legend(x = 'topright', legend = 'Outliers: 5%', 
       box.col = 'white', 
       bg = 'cyan2', cex = 0.7)

# Cambiamos los factores
fda::fbplot(f_rem, x = t_rango, xlim = range(t_rango), 
            ylim = c(-5, 500), frame = FALSE, 
            xlab = 'Emisión espectral', factor = 1.74,
            cex.axis = 0.7, cex.lab = 0.7, 
            ylab = 'Fluoresencia', 
            main = 'Reajuste de factor F')$outpoint
legend(x = 'topright', legend = 'Outliers: 2%', 
       box.col = 'white',
       bg = 'cyan2', cex = 0.7)
```

Mostramos a continuación el boxplot resultante al modificar el factor F.

```{r}
# Boxplot funcional
par(mfrow = c(1, 1))
fda::fbplot(fit = f_hat, x = t_rango, ylim = c(-10, 500), 
       frame = FALSE, main = 'Boxplot funcional ajustado', 
       xlim = range(t_rango), factor = 1.74,
       outliercol = 'white', 
       barcol = adjustcolor('midnightblue', alpha.f = 0.2), 
       color = adjustcolor('brown', alpha.f = 0.2),
       xlab = 'Emisión espectral', 
       ylab = 'Fluoresencia') -> bp_funcional1
matlines(x = t_rango, y = f_hat[, bp_funcional1$outpoint], lty = 1, 
         lwd = 3, col = c('blue4', 'deeppink4'))
legend(legend = bp_funcional1$outpoint, x = 'topright', lwd = 3,
       col = c('blue4', 'deeppink4'), 
       cex = 0.8, box.col = 'white', lty = 1,
       bg = 'azure1')
```

Aunque parece más acertada la salida de la función **roahd::fbplot** usando el parámetro *adjust*.

## La función mediana multivariada

El nivel de excitación que habíamos elegido inicalmente fue de 340. Para llevar a cabo los procedimientos multivariados, tomamos otro nivel de onda correspondiente al valor 325. 

Es decir que tenemos un conjunto de datos funcionales bivariado. Veamos rápidamente el nuevo conjunto de datos y los suavizamoentos correspondientes.

```{r}
# Hacemos la lectura de los datos
datos2 <- read.table(colClasses = rep(c('NULL', 'numeric', 'NULL'), 
                                      c(5, 1, 1)*571), file = ruta)

# Visualizaciones
par(mfrow = c(1, 2))

matplot(x = t_rango, y = t(datos2), type = 'l', frame = FALSE,
        xlab = 'Emisión Espectral', main = 'Nivel 325', ylab = '')

# Ajuste
bk2 <- c(275, 300, 330, 370, 400, 430, 470, 500, 520, 560)
base_bsp2 <- create.bspline.basis(breaks = bk2, 
                                  norder = 4)
ajuste_detallado2 <- smooth.basis(argvals = t_rango, y = t(datos2), fdParobj = base_bsp2)

f_hat2 <- eval.fd(evalarg = t_rango, fdobj = ajuste_detallado2$fd)

matplot(x = t_rango, y = f_hat2, type = 'l', frame = FALSE,
        xlab = 'Emisión Espectral', main = 'Curvas Suavizadas',
        ylab = '')

# Pasamos a datos multiv
multi <- mfData(grid = t_rango, Data_list = list(X1 = t(f_hat), 
                                                 X2 = t(f_hat2)))

# Mediana multiv
mediana_multi <- median_mfData(mfData = multi)
mediana_pos <- which.max(multiMBD(multi))
```

El gráfico respectivo de la mediana multivariada:

```{r}
plot(mediana_multi, main = 'Mediana multivariada, ID 175', 
     frame = FALSE,
     lwd = 2, col = 'gray')
```

## Outliers multivariados

Mostramos los identificadores de los individuos que aparecen como atípicos. 

```{r}
par(mfrow = c(1, 1))
fbplot(multi, frame = FALSE) -> bp_multi

bp_multi$ID_outliers

detach('package:roahd', unload = TRUE)
```

Como vemos, los individuos 10, 71 y 131 aparecen nuevamente como datos atípicos (aún considerando los datos multivariados). Sin embargo nos llamó la atención que el individuo 15 no fuese un outlier a nivel multivariado pero los individuos 14 y 16 si.


# Artículo: Comparative study of different B-spline approaches for functional data {.tabset}


**Referencia del artículo:**
Aguilera, A. M., & Aguilera-Morillo, M. C. (2013). Comparative study of
different B-spline approaches for functional data. Mathematical and
Computer Modelling, 58(7-8), 1568-1579.

Siguiendo la contrucción del artículo de Aguilera, se generan los datos simulados, generando 100 curvas de un proceso estocástico de media cero que sigue que cada curva X, posee un comportamiento dado por $X (t)=R cos (2\pi t+ \theta)$, en el cual $R$ y $\theta$ provienen de una distribución  i.i.d Rayleigh($\sigma$), con $\sigma=0.3$ y Uniforme $[0,2\pi]$, respectivamente.

Se realiza una muestra de observaciones con 51 nodos (knots) igualmente espaciados en el intervalo $T=[0,1]$, en el cual los errores de cada curva se comportan de manera $Normal(0,\sigma²)$ con $\sigma²=0.07$




```{r}
R<-rrayleigh(1, scale = sqrt(0.3))
theta<-runif(1,0,2*pi)
```



```{r}
# Se crea la función que genera las simulaciones
true_functions <- function(x){R*cos(2*pi*x+theta)}
true_functions_2 <- function(x,R_in,theta_in){R_in*cos(2*pi*x+theta_in)}

```

```{r}

#Se genera la función que brinda los valores para generar la simulación con los errores propuestos en el artículo
simulated_functions <- function(lenght.out=51,R_in,theta_in){
errors<-rnorm(lenght.out,mean = 0, sd=sqrt(0.07))
leng_time=seq(0,1,len=lenght.out)
values<-R_in*cos(2*pi*leng_time+theta_in)+errors

return(values)
  }
```

**Regression Splines**
La primera curva a partir de un $R$ y $\theta$ aleatorio se construye, siguiendo las dos bases de nuestro interés. Tanto Fourier como B-Splines

```{r}
simulated_curve<-data.frame(x=seq(0,1,len=51),y=simulated_functions(R_in=R,theta_in=theta),cat="Simulated function")
```



```{r}
create_regression<-function(nbasis,curve){
  basisobj = create.bspline.basis(c(0,1),nbasis)
  ajuste <- Data2fd(y = curve$y, basisobj =basisobj, 
                  argvals = seq(0,1,len=51))
  df <- data.frame(x=seq(0,1,len=51), y = predict(ajuste, newdata=seq(0,1,len=51)),cat=paste(as.character(nbasis),"basic knots"))
  return(df)
}

reg_5<-create_regression(5,simulated_curve)
reg_15<-create_regression(15,simulated_curve)
reg_25<-create_regression(25,simulated_curve)
```




```{r}
create_regression_fourier<-function(nbasis,curve){
  basisobj = create.fourier.basis(rangeval=c(0,1), nbasis=nbasis)
  ajuste <- Data2fd(y = curve$y, basisobj =basisobj, 
                  argvals = seq(0,1,len=51))
  df <- data.frame(x=seq(0,1,len=51), y = predict(ajuste, newdata=seq(0,1,len=51)),cat=paste(as.character(nbasis),"basic knots"))
  return(df)
}

reg_5_f<-create_regression_fourier(5,simulated_curve)
reg_15_f<-create_regression_fourier(15,simulated_curve)
reg_25_f<-create_regression_fourier(25,simulated_curve)
```



se crea la base para la construcción de regresiones splines y smoothing splines, generadas a partir de bases B-Splines y Bases de Fourier, respectivamente, con 51 nodos en el intervalo $T=[0,1]$
```{r}
p_reg_b<-ggplot(data.frame(x=c(0,1),cat="True function"), aes(x=x,colour=cat)) + stat_function(fun=true_functions)+ geom_line(data = simulated_curve,linetype = "dotted",aes(x=x,y=y,colour=cat))+ geom_line(data = reg_5,linetype = "dashed",aes(x=x,y=y,colour=cat))+ geom_line(data = reg_15,linetype = "longdash",aes(x=x,y=y,colour=cat))+ geom_line(data = reg_25,linetype = "dotdash",aes(x=x,y=y,colour=cat))+
  scale_color_manual(name = "Curves", values = c("True function"="black","Simulated function" = "orange", "5 basic knots" = "blue","15 basic knots"="red","25 basic knots"="green"))+ theme_bw()+xlab("Base B-Spline")
p_reg_f<-ggplot(data.frame(x=c(0,1),cat="True function"), aes(x=x,colour=cat)) + stat_function(fun=true_functions)+ geom_line(data = simulated_curve,linetype = "dotted",aes(x=x,y=y,colour=cat))+ geom_line(data = reg_5_f,linetype = "dashed",aes(x=x,y=y,colour=cat))+ geom_line(data = reg_15_f,linetype = "longdash",aes(x=x,y=y,colour=cat))+ geom_line(data = reg_25_f,linetype = "dotdash",aes(x=x,y=y,colour=cat))+
  scale_color_manual(name = "Curves", values = c("True function"="black","Simulated function" = "orange", "5 basic knots" = "blue","15 basic knots"="red","25 basic knots"="green"))+ theme_bw()+xlab("Base Fourier")
p_reg_b/p_reg_f
```










```{r}
samples_regression<-function(nbasis_in){
 R_aux<-rrayleigh(1, scale = sqrt(0.3))
 theta_aux<-runif(1,0,2*pi)
 simulated_curve_aux<-data.frame(x=seq(0,1,len=51),y=simulated_functions(R_in=R_aux,theta_in=theta_aux),cat="Simulated function")
 return(list(create_regression(nbasis_in,simulated_curve_aux)))
}

```


```{r}
samples_reg_5<-list()
samples_reg_15<-list()
samples_reg_25<-list()
for(i in 1:100){
  samples_reg_5<-append(samples_reg_5,list(samples_regression(5)))
  samples_reg_15<-append(samples_reg_15,list(samples_regression(15)))
  samples_reg_25<-append(samples_reg_25,list(samples_regression(25)))
}
```



**Smoothing Splines**

```{r}
create_sm_splines<-function(nbasis,curve,d=2,lambda=10^(-2)){
  basisobj = create.bspline.basis(c(0,1),nbasis)
  fdParobj = fdPar(basisobj, d, lambda)
  smoothlistnowt = smooth.basis(seq(0,1,len=51),  curve$y, fdParobj)
  ajuste <- smoothlistnowt$fd
  df <- suppressWarnings(data.frame(x=seq(0,1,len=51), y = predict(ajuste, newdata=seq(0,1,len=51)),cat=paste(as.character(nbasis),"basic knots"),gcv=smoothlistnowt$gcv))
  return(df)
}

create_sm_splines_fourier<-function(nbasis,curve,d=2,lambda=10^(-2)){
  basisobj = create.fourier.basis(c(0,1),nbasis)
  fdParobj = fdPar(basisobj, d, lambda)
  smoothlistnowt = smooth.basis(seq(0,1,len=51),  curve$y, fdParobj)
  ajuste <- smoothlistnowt$fd
  df <- suppressWarnings(data.frame(x=seq(0,1,len=51), y = predict(ajuste, newdata=seq(0,1,len=51)),cat=paste(as.character(nbasis),"basic knots"),gcv=smoothlistnowt$gcv))
  return(df)
}


```


```{r}
#Calcular lambda
calcular_lambda<-function(inicio,fin,paso,num_basis){
  pruebas=list()
  base_aux=list()
  for(i in 1:100){
    R_aux<-rrayleigh(1, scale = sqrt(0.3))
    theta_aux<-runif(1,0,2*pi)
    base_aux=append(base_aux,simulated_functions(R_in = R_aux,theta_in = theta_aux))
  }
  for(i in num_basis){
    base_bsplines=create.bspline.basis(c(0,1),i)
    base_fourier=create.fourier.basis(c(0,1),i)
    for(j in seq(inicio,fin,paso)){
      fdParobj = fdPar(base_bsplines, 2, j)
      fdParobj_f = fdPar(base_bsplines, 2, j)
      smoothlistnowt = smooth.basis(seq(0,1,len=51),  curve$y, fdParobj)
      smoothlistnowt_f = smooth.basis(seq(0,1,len=51),  curve$y, fdParobj)
      pruebas=append(pruebas,list(base="bspline",))
      pruebas=append(pruebas,list(base="fourier",))
    }
    
  }
}
```



```{r}
reg_5_sm<-create_sm_splines(5,simulated_curve)
reg_15_sm<-create_sm_splines(15,simulated_curve)
reg_25_sm<-create_sm_splines(25,simulated_curve)
reg_5_sm_f<-create_sm_splines_fourier(5,simulated_curve)
reg_15_sm_f<-create_sm_splines_fourier(15,simulated_curve)
reg_25_sm_f<-create_sm_splines_fourier(25,simulated_curve)
```





```{r}
p_spl<-ggplot(data.frame(x=c(0,1),cat="True function"), aes(x=x,colour=cat)) + stat_function(fun=true_functions)+ geom_line(data = simulated_curve,linetype = "dotted",aes(x=x,y=y,colour=cat))+ geom_line(data = reg_5_sm,linetype = "dashed",aes(x=x,y=y,colour=cat))+ geom_line(data = reg_15_sm,linetype = "longdash",aes(x=x,y=y,colour=cat))+ geom_line(data = reg_25_sm,linetype = "dotdash",aes(x=x,y=y,colour=cat))+
  scale_color_manual(name = "Curves", values = c("True function"="black","Simulated function" = "orange", "5 basic knots" = "blue","15 basic knots"="red","25 basic knots"="green"))+ ylab("")+theme_bw()+xlab("Base B-Spline")
p_spl_f<-ggplot(data.frame(x=c(0,1),cat="True function"), aes(x=x,colour=cat)) + stat_function(fun=true_functions)+ geom_line(data = simulated_curve,linetype = "dotted",aes(x=x,y=y,colour=cat))+ geom_line(data = reg_5_sm_f,linetype = "dashed",aes(x=x,y=y,colour=cat))+ geom_line(data = reg_15_sm_f,linetype = "longdash",aes(x=x,y=y,colour=cat))+ geom_line(data = reg_25_sm_f,linetype = "dotdash",aes(x=x,y=y,colour=cat))+
  scale_color_manual(name = "Curves", values = c("True function"="black","Simulated function" = "orange", "5 basic knots" = "blue","15 basic knots"="red","25 basic knots"="green"))+ylab("") +theme_bw()+xlab("Base De Fourier")
p_spl/p_spl_f

```



Para las gráficas que genera el autor, se generan las 100 curvas a partir de la simulación, tal como se menciona en un inicio, y se grafican las funciones


```{r}
R<-rrayleigh(1, scale = sqrt(0.3))
theta<-runif(1,0,2*pi)
```



```{r}
samples_smoothing<-function(nbasis_in,calc_vars=FALSE){
 if(calc_vars!=FALSE){
 R_aux<-rrayleigh(1, scale = sqrt(0.3))
 theta_aux<-runif(1,0,2*pi)
 }else{
  R_aux=R
  theta_aux=theta
 }
 true_func_aux=true_functions_2(seq(0,1,len=51),R_aux,theta_aux)
 simulated_curve_aux<-suppressWarnings(data.frame(x=seq(0,1,len=51),y=simulated_functions(R_in=R_aux,theta_in=theta_aux),cat="Simulated function"))
 sm_aux=suppressWarnings( create_sm_splines(nbasis_in,simulated_curve_aux))
 sm_aux_f=suppressWarnings( create_sm_splines_fourier(nbasis_in,simulated_curve_aux))
 reg_aux=suppressWarnings(create_regression(nbasis_in,simulated_curve_aux))
 reg_aux_f=suppressWarnings(create_regression_fourier(nbasis_in,simulated_curve_aux))
 MSE_reg=mean((reg_aux$y - simulated_curve_aux$y)^2)
 MSE_reg_f=mean((reg_aux_f$y - simulated_curve_aux$y)^2)
 MSE_sm=mean((sm_aux$y - simulated_curve_aux$y)^2)
 MSE_sm_f=mean((sm_aux_f$y - simulated_curve_aux$y)^2)
 return(list(true_f=true_func_aux,reg_spl=reg_aux$y,y=simulated_curve_aux$y,y_hat=sm_aux$y,gcv_reg=reg_aux$gcv[1],gcv_sm=sm_aux$gcv[1],reg_spl_f=reg_aux_f$y,y_hat_f=sm_aux_f$y,gcv_sm_f=sm_aux_f$gcv,MSE_reg=MSE_reg,MSE_reg_f=MSE_reg_f,MSE_sm=MSE_sm,MSE_sm_f=MSE_sm_f))
}
```

Se grafica la función rela, la función simulada con errores normales, y con las bases que definimos en el planteamiento de la simulación (5, 15 y 25). Ajustando también Regresión Spline y Smoothing Spline con un $\lambda=0.01$
```{r}
info_basis5_1<-samples_smoothing(5)
info_basis15_1<-samples_smoothing(15)
info_basis25_1<-samples_smoothing(25)
R<-rrayleigh(1, scale = sqrt(0.3))
theta<-runif(1,0,2*pi)
info_basis5_2<-samples_smoothing(5)
info_basis15_2<-samples_smoothing(15)
info_basis25_2<-samples_smoothing(25)

```



```{r}
p5_1<-ggplot(data.frame(x=seq(0,1,len=51),y=info_basis5_1$true_f,cat="True function"), aes(x=x,y=y,colour=cat)) + geom_line()+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis5_1$y,cat="Simulated function"),linetype = "dotted",aes(x=x,y=y,colour=cat))+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis5_1$reg_spl,cat="Regression Splines"),linetype = "dashed",aes(x=x,y=y,colour=cat))+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis5_1$y_hat,cat="Smoothing splines, Lambda=0.01"),linetype = "dotdash",aes(x=x,y=y,colour=cat))+ scale_color_manual(name = "Curves", values = c("True function"="black","Simulated function" = "orange", "Regression Splines" = "blue","Smoothing splines, Lambda=0.01"="red"))+xlab("5 Basis knots")+ylab("") +theme_bw()+theme(legend.position="none")

p5_2<-ggplot(data.frame(x=seq(0,1,len=51),y=info_basis5_2$true_f,cat="True function"), aes(x=x,y=y,colour=cat)) + geom_line()+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis5_2$y,cat="Simulated function"),linetype = "dotted",aes(x=x,y=y,colour=cat))+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis5_2$reg_spl,cat="Regression Splines"),linetype = "dashed",aes(x=x,y=y,colour=cat))+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis5_2$y_hat,cat="Smoothing splines, Lambda=0.01"),linetype = "dotdash",aes(x=x,y=y,colour=cat))+ scale_color_manual(name = "Curves", values = c("True function"="black","Simulated function" = "orange", "Regression Splines" = "blue","Smoothing splines, Lambda=0.01"="red"))+xlab("5 Basis knots")+ylab("") +theme_bw()
p5_1+p5_2+plot_layout(ncol = 2)


```


```{r}
p15_1<-ggplot(data.frame(x=seq(0,1,len=51),y=info_basis15_1$true_f,cat="True function"), aes(x=x,y=y,colour=cat)) + geom_line()+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis15_1$y,cat="Simulated function"),linetype = "dotted",aes(x=x,y=y,colour=cat))+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis15_1$reg_spl,cat="Regression Splines"),linetype = "dashed",aes(x=x,y=y,colour=cat))+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis15_1$y_hat,cat="Smoothing splines, Lambda=0.01"),linetype = "dotdash",aes(x=x,y=y,colour=cat))+ scale_color_manual(name = "Curves", values = c("True function"="black","Simulated function" = "orange", "Regression Splines" = "blue","Smoothing splines, Lambda=0.01"="red"))+xlab("15 Basis knots")+ylab("") +theme_bw()+theme(legend.position="none")

p15_2<-ggplot(data.frame(x=seq(0,1,len=51),y=info_basis15_2$true_f,cat="True function"), aes(x=x,y=y,colour=cat)) + geom_line()+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis15_2$y,cat="Simulated function"),linetype = "dotted",aes(x=x,y=y,colour=cat))+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis15_2$reg_spl,cat="Regression Splines"),linetype = "dashed",aes(x=x,y=y,colour=cat))+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis15_2$y_hat,cat="Smoothing splines, Lambda=0.01"),linetype = "dotdash",aes(x=x,y=y,colour=cat))+ scale_color_manual(name = "Curves", values = c("True function"="black","Simulated function" = "orange", "Regression Splines" = "blue","Smoothing splines, Lambda=0.01"="red"))+xlab("15 Basis knots")+ylab("") +theme_bw()
p15_1+p15_2
```


```{r}
p25_1<-ggplot(data.frame(x=seq(0,1,len=51),y=info_basis25_1$true_f,cat="True function"), aes(x=x,y=y,colour=cat)) + geom_line()+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis25_1$y,cat="Simulated function"),linetype = "dotted",aes(x=x,y=y,colour=cat))+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis25_1$reg_spl,cat="Regression Splines"),linetype = "dashed",aes(x=x,y=y,colour=cat))+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis25_1$y_hat,cat="Smoothing splines, Lambda=0.01"),linetype = "dotdash",aes(x=x,y=y,colour=cat))+ scale_color_manual(name = "Curves", values = c("True function"="black","Simulated function" = "orange", "Regression Splines" = "blue","Smoothing splines, Lambda=0.01"="red"))+xlab("25 Basis knots")+ylab("") +theme_bw()+theme(legend.position="none")
p25_2<-ggplot(data.frame(x=seq(0,1,len=51),y=info_basis25_2$true_f,cat="True function"), aes(x=x,y=y,colour=cat)) + geom_line()+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis25_2$y,cat="Simulated function"),linetype = "dotted",aes(x=x,y=y,colour=cat))+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis25_2$reg_spl,cat="Regression Splines"),linetype = "dashed",aes(x=x,y=y,colour=cat))+ geom_line(data = data.frame(x=seq(0,1,len=51),y=info_basis25_2$y_hat,cat="Smoothing splines, Lambda=0.01"),linetype = "dotdash",aes(x=x,y=y,colour=cat))+ scale_color_manual(name = "Curves", values = c("True function"="black","Simulated function" = "orange", "Regression Splines" = "blue","Smoothing splines, Lambda=0.01"="red"))+xlab("25 Basis knots")+ylab("") +theme_bw()
p25_1+p25_2
```




```{r}
#ahora sí las muestras
samples_smooth_5<-list()
samples_smooth_15<-list()
samples_smooth_25<-list()
for(i in 1:100){
  samples_smooth_5<-append(samples_smooth_5,list(samples_smoothing(5,calc_vars = TRUE)))
  samples_smooth_15<-append(samples_smooth_15,list(samples_smoothing(15,calc_vars = TRUE)))
  samples_smooth_25<-append(samples_smooth_25,list(samples_smoothing(25,calc_vars = TRUE)))
}
```


```{r}
#generar gcv's
aux_basis_5<-c()
aux_basis_15<-c()
aux_basis_25<-c()
aux_basis_5_f<-c()
aux_basis_15_f<-c()
aux_basis_25_f<-c()
mse_basis5_reg<-c()
mse_basis15_reg<-c()
mse_basis25_reg<-c()
mse_basis5_reg_f<-c()
mse_basis15_reg_f<-c()
mse_basis25_reg_f<-c()
mse_basis5_sm<-c()
mse_basis15_sm<-c()
mse_basis25_sm<-c()
mse_basis5_sm_f<-c()
mse_basis15_sm_f<-c()
mse_basis25_sm_f<-c()
for(i in 1:100){
  aux_basis_5<-append(aux_basis_5,samples_smooth_5[[i]]$gcv_sm)
  aux_basis_15<-append(aux_basis_15,samples_smooth_15[[i]]$gcv_sm)
  aux_basis_25<-append(aux_basis_25,samples_smooth_25[[i]]$gcv_sm)
  ux_basis_5_f<-append(aux_basis_5_f,samples_smooth_5[[i]]$gcv_sm_f)
  aux_basis_15_f<-append(aux_basis_15_f,samples_smooth_15[[i]]$gcv_sm_f)
  aux_basis_25_f<-append(aux_basis_25_f,samples_smooth_25[[i]]$gcv_sm_f)
  mse_basis5_reg<-append(mse_basis5_reg,samples_smooth_5[[i]]$MSE_reg)
  mse_basis15_reg<-append(mse_basis15_reg,samples_smooth_15[[i]]$MSE_reg)
  mse_basis25_reg<-append(mse_basis25_reg,samples_smooth_25[[i]]$MSE_reg)
  mse_basis5_reg_f<-append(mse_basis5_reg_f,samples_smooth_5[[i]]$MSE_reg_f)
  mse_basis15_reg_f<-append(mse_basis15_reg_f,samples_smooth_15[[i]]$MSE_reg_f)
  mse_basis25_reg_f<-append(mse_basis25_reg_f,samples_smooth_25[[i]]$MSE_reg_f)
  mse_basis5_sm<-append(mse_basis5_sm,samples_smooth_5[[i]]$MSE_sm)
  mse_basis15_sm<-append(mse_basis15_sm,samples_smooth_15[[i]]$MSE_sm)
  mse_basis25_sm<-append(mse_basis25_sm,samples_smooth_25[[i]]$MSE_sm)
  mse_basis5_sm_f<-append(mse_basis5_sm_f,samples_smooth_5[[i]]$MSE_sm_f)
  mse_basis15_sm_f<-append(mse_basis15_sm_f,samples_smooth_15[[i]]$MSE_sm_f)
  mse_basis25_sm_f<-append(mse_basis25_sm_f,samples_smooth_25[[i]]$MSE_sm_f)
}

df_gcv<-as.data.frame(c(aux_basis_5,aux_basis_15,aux_basis_25))
df_gcv_f<-as.data.frame(c(aux_basis_5_f,aux_basis_15_f,aux_basis_25_f))
df_gcv$basis<-c(rep("5 basic knots",100),rep("15 basic knots",100),rep("25 basic knots",100))
df_gcv_f$basis<-c(rep("5 basic knots",100),rep("15 basic knots",100),rep("25 basic knots",100))
colnames(df_gcv)<-c("value","basis")
colnames(df_gcv_f)<-c("value","basis")

df_mse_5<-as.data.frame(c(mse_basis5_reg,mse_basis5_sm))
df_mse_5$method<-c(rep("Reggresion",100),rep("Smoothing",100))
colnames(df_mse_5)<-c("value","method")
df_mse_15<-as.data.frame(c(mse_basis15_reg,mse_basis15_sm))
df_mse_15$method<-c(rep("Reggresion",100),rep("Smoothing",100))
colnames(df_mse_15)<-c("value","method")
df_mse_25<-as.data.frame(c(mse_basis25_reg,mse_basis25_sm))
df_mse_25$method<-c(rep("Reggresion",100),rep("Smoothing",100))
colnames(df_mse_25)<-c("value","method")
df_mse_5_f<-as.data.frame(c(mse_basis5_reg_f,mse_basis5_sm_f))
df_mse_5_f$method<-c(rep("Reggresion",100),rep("Smoothing",100))
colnames(df_mse_5_f)<-c("value","method")
df_mse_15_f<-as.data.frame(c(mse_basis15_reg_f,mse_basis15_sm_f))
df_mse_15_f$method<-c(rep("Reggresion",100),rep("Smoothing",100))
colnames(df_mse_15_f)<-c("value","method")
df_mse_25_f<-as.data.frame(c(mse_basis25_reg_f,mse_basis25_sm_f))
df_mse_25_f$method<-c(rep("Reggresion",100),rep("Smoothings",100))
colnames(df_mse_25_f)<-c("value","method")

```



```{r}
#Generar matriz para cada base
mat_basis_5<-c()
mat_basis_15<-c()
mat_basis_25<-c()
mat_basis_reg_5<-c()
mat_basis_reg_15<-c()
mat_basis_reg_25<-c()
mat_basis_sm_5<-c()
mat_basis_sm_15<-c()
mat_basis_sm_25<-c()
for(i in 1:100){
  mat_basis_5<-rbind(mat_basis_5,samples_smooth_5[[i]]$true_f)
  mat_basis_15<-rbind(mat_basis_15,samples_smooth_15[[i]]$true_f)
  mat_basis_25<-rbind(mat_basis_25,samples_smooth_25[[i]]$true_f)
  mat_basis_reg_5<-rbind(mat_basis_reg_5,samples_smooth_5[[i]]$reg_spl)
  mat_basis_reg_15<-rbind(mat_basis_reg_15,samples_smooth_15[[i]]$reg_spl)
  mat_basis_reg_25<-rbind(mat_basis_reg_25,samples_smooth_25[[i]]$reg_spl)
  mat_basis_sm_5<-rbind(mat_basis_sm_5,samples_smooth_5[[i]]$y_hat)
  mat_basis_sm_15<-rbind(mat_basis_sm_15,samples_smooth_15[[i]]$y_hat)
  mat_basis_sm_25<-rbind(mat_basis_sm_25,samples_smooth_25[[i]]$y_hat)
}

```


```{r}
#obtener funcion media
mean_basis_5<-data.frame(x=seq(0,1,len=51),y=apply(X = mat_basis_5, MARGIN = 2, mean),curva="Mean true function")
mean_basis_15<-data.frame(x=seq(0,1,len=51),y=apply(X = mat_basis_15, MARGIN = 2, mean),curva="Mean true function")
mean_basis_25<-data.frame(x=seq(0,1,len=51),y=apply(X = mat_basis_25, MARGIN = 2, mean),curva="Mean true function")
mean_basis_reg_5<-data.frame(x=seq(0,1,len=51),y=apply(X = mat_basis_reg_5, MARGIN = 2, mean),curva="Mean Regression Splines")
mean_basis_reg_15<-data.frame(x=seq(0,1,len=51),y=apply(X = mat_basis_reg_15, MARGIN = 2, mean),curva="Mean Regression Splines")
mean_basis_reg_25<-data.frame(x=seq(0,1,len=51),y=apply(X = mat_basis_reg_25, MARGIN = 2, mean),curva="Mean Regression Splines")
mean_basis_sm_5<-data.frame(x=seq(0,1,len=51),y=apply(X = mat_basis_sm_5, MARGIN = 2, mean),curva="Mean Smoothings Splines")
mean_basis_sm_15<-data.frame(x=seq(0,1,len=51),y=apply(X = mat_basis_sm_15, MARGIN = 2, mean),curva="Mean Smoothings Splines")
mean_basis_sm_25<-data.frame(x=seq(0,1,len=51),y=apply(X = mat_basis_sm_25, MARGIN = 2, mean),curva="Mean Smoothings Splines")

```


Se grafica el boxplot correspondiente a los valores GCV con cada uno de los valores de número de base 

```{r}
p_bp<-ggplot(df_gcv, aes(x=basis, y=value, fill=basis)) +
  geom_boxplot()+xlab("B-Spline")+ylab("")+ theme_bw()+theme(legend.position="none")
p_bp_f<-ggplot(df_gcv_f, aes(x=basis, y=value, fill=basis)) +
  geom_boxplot()+xlab("Bases de Fourier")+ylab("")+ theme_bw()+theme(legend.position="none")
p_bp/p_bp_f
```

Se grafica la función media para las 100 cruvas generadas para cada una de las elecciones de número de bases (5,15 y 25). También se presenta un boxplot de MSE para ambos métodos de ajuste (Smoothing splines y Reggresion Splines)

## graficar con 5 bases

```{r}
p5<-ggplot(mean_basis_5, aes(x=x,y=y,colour=curva)) +geom_line()+ geom_line(data = mean_basis_reg_5,linetype = "dotted",aes(x=x,y=y,colour=curva))+ geom_line(data = mean_basis_sm_5,linetype = "dashed",aes(x=x,y=y,colour=curva))+
  scale_color_manual(name = "Curves", values = c("Mean true function"="black","Mean Regression Splines" = "darkgreen", "Mean Smoothings Splines" = "blue"))+ylab("")+ theme_bw()

bp_5<-ggplot(df_mse_5, aes(x=method, y=value, fill=method)) +
  geom_boxplot()+xlab("B-Spline")+ ylab("MSE")+theme_bw()+theme(legend.position="none")
bp_5_f<-ggplot(df_mse_5_f, aes(x=method, y=value, fill=method)) +
  geom_boxplot()+xlab("Bases de Fourier")+ylab("")+ theme_bw()+theme(legend.position="none")

p5
bp_5+bp_5_f


```
## graficar con 15 bases
```{r}
p15<-ggplot(mean_basis_15, aes(x=x,y=y,colour=curva)) +geom_line()+ geom_line(data = mean_basis_reg_15,linetype = "dotted",aes(x=x,y=y,colour=curva))+ geom_line(data = mean_basis_sm_15,linetype = "dashed",aes(x=x,y=y,colour=curva))+
  scale_color_manual(name = "Curves", values = c("Mean true function"="black","Mean Regression Splines" = "darkgreen", "Mean Smoothings Splines" = "blue"))+ylab("")+ theme_bw()
bp_15<-ggplot(df_mse_15, aes(x=method, y=value, fill=method)) +
  geom_boxplot()+xlab("B-Spline")+ylab("MSE")+ theme_bw()+theme(legend.position="none")
bp_15_f<-ggplot(df_mse_15_f, aes(x=method, y=value, fill=method)) +
  geom_boxplot()+xlab("Bases de Fourier")+ylab("")+ theme_bw()+theme(legend.position="none")

p15
bp_15+bp_15_f


```

## Graficar con 25 bases

```{r}
p25<-ggplot(mean_basis_25, aes(x=x,y=y,colour=curva)) +geom_line()+ geom_line(data = mean_basis_reg_25,linetype = "dotted",aes(x=x,y=y,colour=curva))+ geom_line(data = mean_basis_sm_25,linetype = "dashed",aes(x=x,y=y,colour=curva))+
  scale_color_manual(name = "Curves", values = c("Mean true function"="black","Mean Regression Splines" = "darkgreen", "Mean Smoothings Splines" = "blue"))+ylab("")+theme_bw()


bp_25<-ggplot(df_mse_25, aes(x=method, y=value, fill=method)) +
  geom_boxplot()+xlab("B-Spline")+ylab("MSE")+ theme_bw()+theme(legend.position="none")
bp_25_f<-ggplot(df_mse_25_f, aes(x=method, y=value, fill=method)) +
  geom_boxplot()+xlab("Bases de Fourier")+ylab("")+ theme_bw()+theme(legend.position="none")

p25
bp_25+bp_25_f

```





